{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2f97e68d-b047-4b30-95bc-7fafb2b475a9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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/P39NWjQIKWnp6tChQoqX768du3adcfPW61aNcdpivXq1dPKlSsdM2/SH6tofv311/fdb1Z+pgDAlTDTBgD4S1588UX95z//0UsvvaRjx44pPDxc69evV0xMjFq0aKHGjRs7asPDw7V69WotXrxYxYsXV8GCBVWhQgW1atVK7733ngYPHqx69erp4MGDGjp0qMqUKaObN29muacZM2bo888/V2RkpKpXry673a6TJ09q0qRJ2rt3rwYNGiRPT09JUqtWrTR16lRVrFhRVapU0fbt2/Xhhx/qoYceuu9+Pv74Yz355JOqW7euevToodKlS+vSpUv69ddftXjxYscNyFu3bu24B1qxYsX022+/6aOPPlKpUqVUvnz5++7n7Nmzateunbp166akpCQNHjxY+fPn14ABAzLU9unTRx07dpTNZnOcsvhX+fv7a8CAAXrzzTf11Vdf6YUXXtDnn3+u5s2bq2nTpurSpYtKlCihCxcuaP/+/fr5558doeydd97R4sWL1ahRI73zzjvy9vbWhAkTdOXKFUnOt124XVZ+pgDApZi8EAoA4AFx++qRhmEY58+fN7p3724UL17c8PDwMEqVKmUMGDDAuH79ulPdzp07jTp16hg+Pj6GJMeKgSkpKUb//v2NEiVKGPnz5zeeeOIJY9GiRcZLL71klCpVyuk9lInVI/ft22f069fPqFatmlGsWDHDw8PD8Pf3N+rVq2fMmDHDqTYxMdHo2rWrERAQYPj4+BhPPvmksW7dugwrGt5p9chb46+88opRokQJI1++fEaxYsWM2rVrG++//76jZvTo0Ubt2rWNokWLGp6enkbJkiWNrl27GseOHbvn57i1euSMGTOMqKgoo1ixYoaXl5dRt25dY9u2bXd8TUpKiuHl5WU0a9bsnu/9Z7dWj9y6dWuGbdeuXTNKlixplC9f3rh586ZhGIaxa9cuo0OHDkZAQICRL18+IygoyGjYsKExYcIEp9euW7fOqFGjhuHl5WUEBQUZ//znPx0rQF68eNFRd/t3bRiZ/5mSZPTq1StD36VKlcrUSqUA8CCxGcafzrsAAAAPpMWLF6tNmzZaunSpY0EUK4mIiNCxY8f0yy+/mN0KADxwOD0SAIAH2L59+/Tbb7+pX79+euyxx9S8eXOzW1J0dLQef/xxhYSE6MKFC5o1a5aWL1+uyZMnm90aADyQ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m9QVAAAAgLyMmbYsio6OVufOnVWtWjXVqlVLX3zxhY4fP67u3bub3RoAAACAPIjQlkUdO3bU+fPnNXToUMXHxyssLEzff/+9SpUqZXZryAQvLy8NHjw4wymrgCvhOAA4DgCJ4+BBYjPut74kAAAAAMA0XNMGAAAAABZGaAMAAAAACyO0AQAAAICFEdoAAAAAwMIIbQAAAABgYSz5DwAAXMa+fft0/PhxpaamOo23adPGpI6A3LV161Z9/fXXdzwOFixYYFJXuB9CG1zCN998o3nz5t3xf1A///yzSV0B5khNTdXRo0f18MMPy8ODvwbgGo4cOaJ27dppz549stlsunXHI5vNJklKS0szsz0gV8yZM0cvvviiIiIitHz5ckVEROjQoUNKSEhQu3btzG4P98DpkcjzPvnkE7388ssKCAjQjh079Le//U1FihTRkSNH1Lx5c7PbA3LN1atX1bVrV/n4+Khy5co6fvy4JCkqKkojRowwuTsgZ/Xp00dlypTRmTNn5OPjo71792rt2rWqVq2aVq9ebXZ7QK6IiYnR2LFjtWTJEnl6eurjjz/W/v371aFDB5UsWdLs9nAPhDbkeZ9++qm++OILjR8/Xp6ennrzzTe1fPlyRUVFKSkpyez2gFwzYMAA7dq1S6tXr1b+/Pkd440bN9bcuXNN7AzIeZs2bdLQoUNVrFgxubm5yc3NTU8++aSGDx+uqKgos9sDcsXhw4fVsmVLSZKXl5euXLkim82mN954Q1988YXJ3eFeCG3I844fP67atWtLkry9vXXp0iVJUufOnTV79mwzWwNy1aJFizR+/Hg9+eSTjlPCJCk0NFSHDx82sTMg56WlpalAgQKSpKJFi+r06dOSpFKlSungwYNmtgbkmsKFCzv+HVSiRAnFxcVJki5evKirV6+a2Rrug9CGPC8oKEjnz5+X9Mdfzps3b5YkHT161HFNA+AKzp07p4CAgAzjt37TCuRlYWFh2r17tySpRo0aGjlypDZs2KChQ4eqbNmyJncH5I66detq+fLlkqQOHTqoT58+6tatm55//nk1atTI5O5wL1yBjjyvYcOGWrx4sZ544gl17dpVb7zxhr755htt27ZN7du3N7s9INdUr15dS5cu1euvvy7p/xdgmDhxomrVqmVma0CO+/e//60rV65Ikt5//321atVKdevWVZEiRTg9GC5j/Pjxun79uqQ/TpnPly+f1q9fr/bt22vgwIEmd4d7sRlMNSCPS09PV3p6umOVvHnz5mn9+vUqV66cunfvLk9PT5M7BHLHxo0b1axZM3Xq1ElTp07Va6+9pr1792rTpk1as2aNqlatanaLQK66cOGC/P39mWkGYHmENgBwIXv27NGoUaO0fft2paen64knntBbb72l8PBws1sDclRSUpLS0tJUuHBhp/ELFy7Iw8NDfn5+JnUG5J7vv/9e7u7uatq0qdP4smXLlJaWxqraFkZoQ560e/duhYWFyc3NzXENw91UqVIll7oCAJilefPmat26tXr27Ok0PmHCBH333Xf6/vvvTeoMyD1VqlTRiBEj1KJFC6fx2NhYvfXWW9q1a5dJneF+CG3Ik9zc3JSQkKCAgAC5ubk53Uj1z2w2GzdUhUtJS0vTwoULtX//ftlsNlWqVElPP/00N9lGnle4cGFt2LBBlSpVcho/cOCA6tSp41iwCsjLvL29tX//fpUuXdpp/NixY6pcubLjuk9YD39LI086evSoihUr5vgzACkuLk5PP/20EhISVKFCBUnSL7/8omLFium7777jFEnkaSkpKbp582aG8Rs3bujatWsmdATkPrvdriNHjmQIbb/++qt8fX3NaQqZwkwbALiImjVrKiAgQNOmTZO/v78kKTExUV26dNHZs2e1adMmkzsEck79+vUVHh6ucePGOY336tVLu3fv1rp160zqDMg9r776qjZv3qyFCxfq4YcflvRHYHvmmWdUvXp1TZo0yeQOcTeENuR506ZNU9GiRdWyZUtJ0ptvvqkvvvhCoaGhmj17tkqVKmVyh0Du8Pb21rZt21S5cmWn8bi4OFWvXp3ZBuRpGzZsUOPGjVW9enXH/ahWrFihrVu3atmyZapbt67JHQI5LykpSc2aNdO2bdv00EMPSZJOnjypunXrasGCBSpUqJC5DeKuuLk28ryYmBh5e3tLkjZt2qTx48dr5MiRKlq0qN544w2TuwNyT4UKFXTmzJkM42fPnlW5cuVM6AjIPXXq1NGmTZsUEhKiefPmafHixSpXrpx2795NYIPLsNvt2rhxo5YuXaqePXuqX79+WrFihVauXElgszhm2pDn+fj46MCBAypZsqTeeustxcfHa/r06dq7d6/q16+vc+fOmd0ikCu+//57vfnmmxoyZIhq1qwpSdq8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",
      "text/plain": [
       "<Figure size 1000x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyError",
     "evalue": "\"Column(s) ['Price'] do not exist\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[2], line 33\u001b[0m\n\u001b[0;32m     29\u001b[0m plt\u001b[38;5;241m.\u001b[39mshow()\n\u001b[0;32m     31\u001b[0m \u001b[38;5;66;03m# Task 2: Lookalike Model\u001b[39;00m\n\u001b[0;32m     32\u001b[0m \u001b[38;5;66;03m# Feature engineering\u001b[39;00m\n\u001b[1;32m---> 33\u001b[0m customer_features \u001b[38;5;241m=\u001b[39m merged_data\u001b[38;5;241m.\u001b[39mgroupby(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCustomerID\u001b[39m\u001b[38;5;124m\"\u001b[39m)\u001b[38;5;241m.\u001b[39magg({\n\u001b[0;32m     34\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124msum\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     35\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mcount\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     36\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmean\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     37\u001b[0m })\u001b[38;5;241m.\u001b[39mrename(columns\u001b[38;5;241m=\u001b[39m{\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalSpend\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionCount\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAvgPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m})\n\u001b[0;32m     39\u001b[0m \u001b[38;5;66;03m# Compute similarity\u001b[39;00m\n\u001b[0;32m     40\u001b[0m scaler \u001b[38;5;241m=\u001b[39m StandardScaler()\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\groupby\\generic.py:1432\u001b[0m, in \u001b[0;36mDataFrameGroupBy.aggregate\u001b[1;34m(self, func, engine, engine_kwargs, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1429\u001b[0m     kwargs[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m] \u001b[38;5;241m=\u001b[39m engine_kwargs\n\u001b[0;32m   1431\u001b[0m op \u001b[38;5;241m=\u001b[39m GroupByApply(\u001b[38;5;28mself\u001b[39m, func, args\u001b[38;5;241m=\u001b[39margs, kwargs\u001b[38;5;241m=\u001b[39mkwargs)\n\u001b[1;32m-> 1432\u001b[0m result \u001b[38;5;241m=\u001b[39m op\u001b[38;5;241m.\u001b[39magg()\n\u001b[0;32m   1433\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m is_dict_like(func) \u001b[38;5;129;01mand\u001b[39;00m result \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   1434\u001b[0m     \u001b[38;5;66;03m# GH #52849\u001b[39;00m\n\u001b[0;32m   1435\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mas_index \u001b[38;5;129;01mand\u001b[39;00m is_list_like(func):\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:190\u001b[0m, in \u001b[0;36mApply.agg\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    187\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mapply_str()\n\u001b[0;32m    189\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_dict_like(func):\n\u001b[1;32m--> 190\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_dict_like()\n\u001b[0;32m    191\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m is_list_like(func):\n\u001b[0;32m    192\u001b[0m     \u001b[38;5;66;03m# we require a list, but not a 'str'\u001b[39;00m\n\u001b[0;32m    193\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_list_like()\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:423\u001b[0m, in \u001b[0;36mApply.agg_dict_like\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    415\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21magg_dict_like\u001b[39m(\u001b[38;5;28mself\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m Series:\n\u001b[0;32m    416\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    417\u001b[0m \u001b[38;5;124;03m    Compute aggregation in the case of a dict-like argument.\u001b[39;00m\n\u001b[0;32m    418\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    421\u001b[0m \u001b[38;5;124;03m    Result of aggregation.\u001b[39;00m\n\u001b[0;32m    422\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m--> 423\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_or_apply_dict_like(op_name\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124magg\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:1608\u001b[0m, in \u001b[0;36mGroupByApply.agg_or_apply_dict_like\u001b[1;34m(self, op_name)\u001b[0m\n\u001b[0;32m   1603\u001b[0m     kwargs\u001b[38;5;241m.\u001b[39mupdate({\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine_kwargs})\n\u001b[0;32m   1605\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m com\u001b[38;5;241m.\u001b[39mtemp_setattr(\n\u001b[0;32m   1606\u001b[0m     obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mTrue\u001b[39;00m, condition\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mhasattr\u001b[39m(obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   1607\u001b[0m ):\n\u001b[1;32m-> 1608\u001b[0m     result_index, result_data \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcompute_dict_like(\n\u001b[0;32m   1609\u001b[0m         op_name, selected_obj, selection, kwargs\n\u001b[0;32m   1610\u001b[0m     )\n\u001b[0;32m   1611\u001b[0m result \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mwrap_results_dict_like(selected_obj, result_index, result_data)\n\u001b[0;32m   1612\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m result\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:462\u001b[0m, in \u001b[0;36mApply.compute_dict_like\u001b[1;34m(self, op_name, selected_obj, selection, kwargs)\u001b[0m\n\u001b[0;32m    460\u001b[0m is_groupby \u001b[38;5;241m=\u001b[39m \u001b[38;5;28misinstance\u001b[39m(obj, (DataFrameGroupBy, SeriesGroupBy))\n\u001b[0;32m    461\u001b[0m func \u001b[38;5;241m=\u001b[39m cast(AggFuncTypeDict, \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc)\n\u001b[1;32m--> 462\u001b[0m func \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mnormalize_dictlike_arg(op_name, selected_obj, func)\n\u001b[0;32m    464\u001b[0m is_non_unique_col \u001b[38;5;241m=\u001b[39m (\n\u001b[0;32m    465\u001b[0m     selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m2\u001b[39m\n\u001b[0;32m    466\u001b[0m     \u001b[38;5;129;01mand\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mnunique() \u001b[38;5;241m<\u001b[39m \u001b[38;5;28mlen\u001b[39m(selected_obj\u001b[38;5;241m.\u001b[39mcolumns)\n\u001b[0;32m    467\u001b[0m )\n\u001b[0;32m    469\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m    470\u001b[0m     \u001b[38;5;66;03m# key only used for output\u001b[39;00m\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:663\u001b[0m, in \u001b[0;36mApply.normalize_dictlike_arg\u001b[1;34m(self, how, obj, func)\u001b[0m\n\u001b[0;32m    661\u001b[0m     cols \u001b[38;5;241m=\u001b[39m Index(\u001b[38;5;28mlist\u001b[39m(func\u001b[38;5;241m.\u001b[39mkeys()))\u001b[38;5;241m.\u001b[39mdifference(obj\u001b[38;5;241m.\u001b[39mcolumns, sort\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[0;32m    662\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(cols) \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m--> 663\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mColumn(s) \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mlist\u001b[39m(cols)\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m do not exist\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m    665\u001b[0m aggregator_types \u001b[38;5;241m=\u001b[39m (\u001b[38;5;28mlist\u001b[39m, \u001b[38;5;28mtuple\u001b[39m, \u001b[38;5;28mdict\u001b[39m)\n\u001b[0;32m    667\u001b[0m \u001b[38;5;66;03m# if we have a dict of any non-scalars\u001b[39;00m\n\u001b[0;32m    668\u001b[0m \u001b[38;5;66;03m# eg. {'A' : ['mean']}, normalize all to\u001b[39;00m\n\u001b[0;32m    669\u001b[0m \u001b[38;5;66;03m# be list-likes\u001b[39;00m\n\u001b[0;32m    670\u001b[0m \u001b[38;5;66;03m# Cannot use func.values() because arg may be a Series\u001b[39;00m\n",
      "\u001b[1;31mKeyError\u001b[0m: \"Column(s) ['Price'] do not exist\""
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Task 1: Exploratory Data Analysis (EDA)\n",
    "# Load the datasets\n",
    "customers = pd.read_csv(\"Customers.csv\")\n",
    "products = pd.read_csv(\"Products.csv\")\n",
    "transactions = pd.read_csv(\"Transactions.csv\")\n",
    "\n",
    "# Merge datasets for comprehensive analysis\n",
    "merged_data = transactions.merge(customers, on=\"CustomerID\").merge(products, on=\"ProductID\")\n",
    "\n",
    "# Basic EDA\n",
    "summary_stats = merged_data.describe()\n",
    "sales_by_region = merged_data.groupby(\"Region\")[\"TotalValue\"].sum()\n",
    "top_products = merged_data.groupby(\"ProductName\")[\"TotalValue\"].sum().sort_values(ascending=False).head(5)\n",
    "\n",
    "# Visualization (e.g., sales trends, region analysis)\n",
    "plt.figure(figsize=(10, 6))\n",
    "sales_by_region.plot(kind=\"bar\", title=\"Total Sales by Region\")\n",
    "plt.xlabel(\"Region\")\n",
    "plt.ylabel(\"Total Sales\")\n",
    "plt.show()\n",
    "\n",
    "# Task 2: Lookalike Model\n",
    "# Feature engineering\n",
    "customer_features = merged_data.groupby(\"CustomerID\").agg({\n",
    "    \"TotalValue\": \"sum\",\n",
    "    \"TransactionID\": \"count\",\n",
    "    \"Price\": \"mean\",\n",
    "}).rename(columns={\"TotalValue\": \"TotalSpend\", \"TransactionID\": \"TransactionCount\", \"Price\": \"AvgPrice\"})\n",
    "\n",
    "# Compute similarity\n",
    "scaler = StandardScaler()\n",
    "scaled_features = scaler.fit_transform(customer_features)\n",
    "similarity_matrix = cosine_similarity(scaled_features)\n",
    "\n",
    "# Recommend top 3 lookalikes for each customer\n",
    "lookalikes = {}\n",
    "customer_ids = customer_features.index.tolist()\n",
    "for i, customer_id in enumerate(customer_ids):\n",
    "    similar_indices = np.argsort(-similarity_matrix[i])[1:4]  # Top 3 excluding self\n",
    "    lookalikes[customer_id] = [\n",
    "        (customer_ids[j], round(similarity_matrix[i, j], 4)) for j in similar_indices\n",
    "    ]\n",
    "\n",
    "# Save Lookalike results\n",
    "lookalike_df = pd.DataFrame({\n",
    "    \"CustomerID\": list(lookalikes.keys()),\n",
    "    \"Lookalikes\": [str(v) for v in lookalikes.values()]\n",
    "})\n",
    "lookalike_df.to_csv(\"Lookalike.csv\", index=False)\n",
    "\n",
    "# Task 3: Customer Segmentation (Clustering)\n",
    "# Prepare data for clustering\n",
    "clustering_data = customer_features.copy()\n",
    "scaled_clustering_data = scaler.fit_transform(clustering_data)\n",
    "\n",
    "# Apply KMeans clustering\n",
    "kmeans = KMeans(n_clusters=4, random_state=42)\n",
    "clusters = kmeans.fit_predict(scaled_clustering_data)\n",
    "clustering_data[\"Cluster\"] = clusters\n",
    "\n",
    "# Evaluate clustering\n",
    "db_index = davies_bouldin_score(scaled_clustering_data, clusters)\n",
    "\n",
    "# Visualize clusters\n",
    "plt.figure(figsize=(8, 6))\n",
    "sns.scatterplot(\n",
    "    x=clustering_data[\"TotalSpend\"],\n",
    "    y=clustering_data[\"TransactionCount\"],\n",
    "    hue=clustering_data[\"Cluster\"],\n",
    "    palette=\"viridis\",\n",
    "    legend=\"full\"\n",
    ")\n",
    "plt.title(\"Customer Clusters\")\n",
    "plt.xlabel(\"Total Spend\")\n",
    "plt.ylabel(\"Transaction Count\")\n",
    "plt.show()\n",
    "\n",
    "# Save clustering results\n",
    "clustering_data.to_csv(\"ClusteringResults.csv\", index=False)\n",
    "\n",
    "# Print summaries for review\n",
    "print(\"EDA Summary Statistics:\\n\", summary_stats)\n",
    "print(\"Top 5 Products by Sales:\\n\", top_products)\n",
    "print(\"Davies-Bouldin Index for Clustering:\", db_index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "df51c671-06f8-4e7c-8a79-ed5786f4921c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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/P39NWjQIKWnp6tChQoqX768du3adcfPW61aNcdpivXq1dPKlSsdM2/SH6tofv311/fdb1Z+pgDAlTDTBgD4S1588UX95z//0UsvvaRjx44pPDxc69evV0xMjFq0aKHGjRs7asPDw7V69WotXrxYxYsXV8GCBVWhQgW1atVK7733ngYPHqx69erp4MGDGjp0qMqUKaObN29muacZM2bo888/V2RkpKpXry673a6TJ09q0qRJ2rt3rwYNGiRPT09JUqtWrTR16lRVrFhRVapU0fbt2/Xhhx/qoYceuu9+Pv74Yz355JOqW7euevToodKlS+vSpUv69ddftXjxYscNyFu3bu24B1qxYsX022+/6aOPPlKpUqVUvnz5++7n7Nmzateunbp166akpCQNHjxY+fPn14ABAzLU9unTRx07dpTNZnOcsvhX+fv7a8CAAXrzzTf11Vdf6YUXXtDnn3+u5s2bq2nTpurSpYtKlCihCxcuaP/+/fr5558doeydd97R4sWL1ahRI73zzjvy9vbWhAkTdOXKFUnOt124XVZ+pgDApZi8EAoA4AFx++qRhmEY58+fN7p3724UL17c8PDwMEqVKmUMGDDAuH79ulPdzp07jTp16hg+Pj6GJMeKgSkpKUb//v2NEiVKGPnz5zeeeOIJY9GiRcZLL71klCpVyuk9lInVI/ft22f069fPqFatmlGsWDHDw8PD8Pf3N+rVq2fMmDHDqTYxMdHo2rWrERAQYPj4+BhPPvmksW7dugwrGt5p9chb46+88opRokQJI1++fEaxYsWM2rVrG++//76jZvTo0Ubt2rWNokWLGp6enkbJkiWNrl27GseOHbvn57i1euSMGTOMqKgoo1ixYoaXl5dRt25dY9u2bXd8TUpKiuHl5WU0a9bsnu/9Z7dWj9y6dWuGbdeuXTNKlixplC9f3rh586ZhGIaxa9cuo0OHDkZAQICRL18+IygoyGjYsKExYcIEp9euW7fOqFGjhuHl5WUEBQUZ//znPx0rQF68eNFRd/t3bRiZ/5mSZPTq1StD36VKlcrUSqUA8CCxGcafzrsAAAAPpMWLF6tNmzZaunSpY0EUK4mIiNCxY8f0yy+/mN0KADxwOD0SAIAH2L59+/Tbb7+pX79+euyxx9S8eXOzW1J0dLQef/xxhYSE6MKFC5o1a5aWL1+uyZMnm90aADyQ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m9QVAAAAgLyMmbYsio6OVufOnVWtWjXVqlVLX3zxhY4fP67u3bub3RoAAACAPIjQlkUdO3bU+fPnNXToUMXHxyssLEzff/+9SpUqZXZryAQvLy8NHjw4wymrgCvhOAA4DgCJ4+BBYjPut74kAAAAAMA0XNMGAAAAABZGaAMAAAAACyO0AQAAAICFEdoAAAAAwMIIbQAAAABgYSz5DwAAXMa+fft0/PhxpaamOo23adPGpI6A3LV161Z9/fXXdzwOFixYYFJXuB9CG1zCN998o3nz5t3xf1A///yzSV0B5khNTdXRo0f18MMPy8ODvwbgGo4cOaJ27dppz549stlsunXHI5vNJklKS0szsz0gV8yZM0cvvviiIiIitHz5ckVEROjQoUNKSEhQu3btzG4P98DpkcjzPvnkE7388ssKCAjQjh079Le//U1FihTRkSNH1Lx5c7PbA3LN1atX1bVrV/n4+Khy5co6fvy4JCkqKkojRowwuTsgZ/Xp00dlypTRmTNn5OPjo71792rt2rWqVq2aVq9ebXZ7QK6IiYnR2LFjtWTJEnl6eurjjz/W/v371aFDB5UsWdLs9nAPhDbkeZ9++qm++OILjR8/Xp6ennrzzTe1fPlyRUVFKSkpyez2gFwzYMAA7dq1S6tXr1b+/Pkd440bN9bcuXNN7AzIeZs2bdLQoUNVrFgxubm5yc3NTU8++aSGDx+uqKgos9sDcsXhw4fVsmVLSZKXl5euXLkim82mN954Q1988YXJ3eFeCG3I844fP67atWtLkry9vXXp0iVJUufOnTV79mwzWwNy1aJFizR+/Hg9+eSTjlPCJCk0NFSHDx82sTMg56WlpalAgQKSpKJFi+r06dOSpFKlSungwYNmtgbkmsKFCzv+HVSiRAnFxcVJki5evKirV6+a2Rrug9CGPC8oKEjnz5+X9Mdfzps3b5YkHT161HFNA+AKzp07p4CAgAzjt37TCuRlYWFh2r17tySpRo0aGjlypDZs2KChQ4eqbNmyJncH5I66detq+fLlkqQOHTqoT58+6tatm55//nk1atTI5O5wL1yBjjyvYcOGWrx4sZ544gl17dpVb7zxhr755htt27ZN7du3N7s9INdUr15dS5cu1euvvy7p/xdgmDhxomrVqmVma0CO+/e//60rV65Ikt5//321atVKdevWVZEiRTg9GC5j/Pjxun79uqQ/TpnPly+f1q9fr/bt22vgwIEmd4d7sRlMNSCPS09PV3p6umOVvHnz5mn9+vUqV66cunfvLk9PT5M7BHLHxo0b1axZM3Xq1ElTp07Va6+9pr1792rTpk1as2aNqlatanaLQK66cOGC/P39mWkGYHmENgBwIXv27NGoUaO0fft2paen64knntBbb72l8PBws1sDclRSUpLS0tJUuHBhp/ELFy7Iw8NDfn5+JnUG5J7vv/9e7u7uatq0qdP4smXLlJaWxqraFkZoQ560e/duhYWFyc3NzXENw91UqVIll7oCAJilefPmat26tXr27Ok0PmHCBH333Xf6/vvvTeoMyD1VqlTRiBEj1KJFC6fx2NhYvfXWW9q1a5dJneF+CG3Ik9zc3JSQkKCAgAC5ubk53Uj1z2w2GzdUhUtJS0vTwoULtX//ftlsNlWqVElPP/00N9lGnle4cGFt2LBBlSpVcho/cOCA6tSp41iwCsjLvL29tX//fpUuXdpp/NixY6pcubLjuk9YD39LI086evSoihUr5vgzACkuLk5PP/20EhISVKFCBUnSL7/8omLFium7777jFEnkaSkpKbp582aG8Rs3bujatWsmdATkPrvdriNHjmQIbb/++qt8fX3NaQqZwkwbALiImjVrKiAgQNOmTZO/v78kKTExUV26dNHZs2e1adMmkzsEck79+vUVHh6ucePGOY336tVLu3fv1rp160zqDMg9r776qjZv3qyFCxfq4YcflvRHYHvmmWdUvXp1TZo0yeQOcTeENuR506ZNU9GiRdWyZUtJ0ptvvqkvvvhCoaGhmj17tkqVKmVyh0Du8Pb21rZt21S5cmWn8bi4OFWvXp3ZBuRpGzZsUOPGjVW9enXH/ahWrFihrVu3atmyZapbt67JHQI5LykpSc2aNdO2bdv00EMPSZJOnjypunXrasGCBSpUqJC5DeKuuLk28ryYmBh5e3tLkjZt2qTx48dr5MiRKlq0qN544w2TuwNyT4UKFXTmzJkM42fPnlW5cuVM6AjIPXXq1NGmTZsUEhKiefPmafHixSpXrpx2795NYIPLsNvt2rhxo5YuXaqePXuqX79+WrFihVauXElgszhm2pDn+fj46MCBAypZsqTeeustxcfHa/r06dq7d6/q16+vc+fOmd0ikCu+//57vfnmmxoyZIhq1qwpSdq8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",
      "text/plain": [
       "<Figure size 1000x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyError",
     "evalue": "\"Column(s) ['Price'] do not exist\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 33\u001b[0m\n\u001b[0;32m     29\u001b[0m plt\u001b[38;5;241m.\u001b[39mshow()\n\u001b[0;32m     31\u001b[0m \u001b[38;5;66;03m# Task 2: Lookalike Model\u001b[39;00m\n\u001b[0;32m     32\u001b[0m \u001b[38;5;66;03m# Feature engineering\u001b[39;00m\n\u001b[1;32m---> 33\u001b[0m customer_features \u001b[38;5;241m=\u001b[39m merged_data\u001b[38;5;241m.\u001b[39mgroupby(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCustomerID\u001b[39m\u001b[38;5;124m\"\u001b[39m)\u001b[38;5;241m.\u001b[39magg({\n\u001b[0;32m     34\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124msum\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     35\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mcount\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     36\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmean\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m     37\u001b[0m })\u001b[38;5;241m.\u001b[39mrename(columns\u001b[38;5;241m=\u001b[39m{\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalSpend\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionCount\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAvgPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m})\n\u001b[0;32m     39\u001b[0m \u001b[38;5;66;03m# Ensure features are numerical and handle missing values if any\u001b[39;00m\n\u001b[0;32m     40\u001b[0m customer_features \u001b[38;5;241m=\u001b[39m customer_features\u001b[38;5;241m.\u001b[39mfillna(\u001b[38;5;241m0\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\groupby\\generic.py:1432\u001b[0m, in \u001b[0;36mDataFrameGroupBy.aggregate\u001b[1;34m(self, func, engine, engine_kwargs, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1429\u001b[0m     kwargs[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m] \u001b[38;5;241m=\u001b[39m engine_kwargs\n\u001b[0;32m   1431\u001b[0m op \u001b[38;5;241m=\u001b[39m GroupByApply(\u001b[38;5;28mself\u001b[39m, func, args\u001b[38;5;241m=\u001b[39margs, kwargs\u001b[38;5;241m=\u001b[39mkwargs)\n\u001b[1;32m-> 1432\u001b[0m result \u001b[38;5;241m=\u001b[39m op\u001b[38;5;241m.\u001b[39magg()\n\u001b[0;32m   1433\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m is_dict_like(func) \u001b[38;5;129;01mand\u001b[39;00m result \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   1434\u001b[0m     \u001b[38;5;66;03m# GH #52849\u001b[39;00m\n\u001b[0;32m   1435\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mas_index \u001b[38;5;129;01mand\u001b[39;00m is_list_like(func):\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:190\u001b[0m, in \u001b[0;36mApply.agg\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    187\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mapply_str()\n\u001b[0;32m    189\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_dict_like(func):\n\u001b[1;32m--> 190\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_dict_like()\n\u001b[0;32m    191\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m is_list_like(func):\n\u001b[0;32m    192\u001b[0m     \u001b[38;5;66;03m# we require a list, but not a 'str'\u001b[39;00m\n\u001b[0;32m    193\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_list_like()\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:423\u001b[0m, in \u001b[0;36mApply.agg_dict_like\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    415\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21magg_dict_like\u001b[39m(\u001b[38;5;28mself\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m Series:\n\u001b[0;32m    416\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    417\u001b[0m \u001b[38;5;124;03m    Compute aggregation in the case of a dict-like argument.\u001b[39;00m\n\u001b[0;32m    418\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    421\u001b[0m \u001b[38;5;124;03m    Result of aggregation.\u001b[39;00m\n\u001b[0;32m    422\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m--> 423\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_or_apply_dict_like(op_name\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124magg\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:1608\u001b[0m, in \u001b[0;36mGroupByApply.agg_or_apply_dict_like\u001b[1;34m(self, op_name)\u001b[0m\n\u001b[0;32m   1603\u001b[0m     kwargs\u001b[38;5;241m.\u001b[39mupdate({\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine_kwargs})\n\u001b[0;32m   1605\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m com\u001b[38;5;241m.\u001b[39mtemp_setattr(\n\u001b[0;32m   1606\u001b[0m     obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mTrue\u001b[39;00m, condition\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mhasattr\u001b[39m(obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   1607\u001b[0m ):\n\u001b[1;32m-> 1608\u001b[0m     result_index, result_data \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcompute_dict_like(\n\u001b[0;32m   1609\u001b[0m         op_name, selected_obj, selection, kwargs\n\u001b[0;32m   1610\u001b[0m     )\n\u001b[0;32m   1611\u001b[0m result \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mwrap_results_dict_like(selected_obj, result_index, result_data)\n\u001b[0;32m   1612\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m result\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:462\u001b[0m, in \u001b[0;36mApply.compute_dict_like\u001b[1;34m(self, op_name, selected_obj, selection, kwargs)\u001b[0m\n\u001b[0;32m    460\u001b[0m is_groupby \u001b[38;5;241m=\u001b[39m \u001b[38;5;28misinstance\u001b[39m(obj, (DataFrameGroupBy, SeriesGroupBy))\n\u001b[0;32m    461\u001b[0m func \u001b[38;5;241m=\u001b[39m cast(AggFuncTypeDict, \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc)\n\u001b[1;32m--> 462\u001b[0m func \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mnormalize_dictlike_arg(op_name, selected_obj, func)\n\u001b[0;32m    464\u001b[0m is_non_unique_col \u001b[38;5;241m=\u001b[39m (\n\u001b[0;32m    465\u001b[0m     selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m2\u001b[39m\n\u001b[0;32m    466\u001b[0m     \u001b[38;5;129;01mand\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mnunique() \u001b[38;5;241m<\u001b[39m \u001b[38;5;28mlen\u001b[39m(selected_obj\u001b[38;5;241m.\u001b[39mcolumns)\n\u001b[0;32m    467\u001b[0m )\n\u001b[0;32m    469\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m    470\u001b[0m     \u001b[38;5;66;03m# key only used for output\u001b[39;00m\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:663\u001b[0m, in \u001b[0;36mApply.normalize_dictlike_arg\u001b[1;34m(self, how, obj, func)\u001b[0m\n\u001b[0;32m    661\u001b[0m     cols \u001b[38;5;241m=\u001b[39m Index(\u001b[38;5;28mlist\u001b[39m(func\u001b[38;5;241m.\u001b[39mkeys()))\u001b[38;5;241m.\u001b[39mdifference(obj\u001b[38;5;241m.\u001b[39mcolumns, sort\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[0;32m    662\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(cols) \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m--> 663\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mColumn(s) \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mlist\u001b[39m(cols)\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m do not exist\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m    665\u001b[0m aggregator_types \u001b[38;5;241m=\u001b[39m (\u001b[38;5;28mlist\u001b[39m, \u001b[38;5;28mtuple\u001b[39m, \u001b[38;5;28mdict\u001b[39m)\n\u001b[0;32m    667\u001b[0m \u001b[38;5;66;03m# if we have a dict of any non-scalars\u001b[39;00m\n\u001b[0;32m    668\u001b[0m \u001b[38;5;66;03m# eg. {'A' : ['mean']}, normalize all to\u001b[39;00m\n\u001b[0;32m    669\u001b[0m \u001b[38;5;66;03m# be list-likes\u001b[39;00m\n\u001b[0;32m    670\u001b[0m \u001b[38;5;66;03m# Cannot use func.values() because arg may be a Series\u001b[39;00m\n",
      "\u001b[1;31mKeyError\u001b[0m: \"Column(s) ['Price'] do not exist\""
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Task 1: Exploratory Data Analysis (EDA)\n",
    "# Load the datasets\n",
    "customers = pd.read_csv(\"Customers.csv\")\n",
    "products = pd.read_csv(\"Products.csv\")\n",
    "transactions = pd.read_csv(\"Transactions.csv\")\n",
    "\n",
    "# Merge datasets for comprehensive analysis\n",
    "merged_data = transactions.merge(customers, on=\"CustomerID\").merge(products, on=\"ProductID\")\n",
    "\n",
    "# Basic EDA\n",
    "summary_stats = merged_data.describe()\n",
    "sales_by_region = merged_data.groupby(\"Region\")[\"TotalValue\"].sum()\n",
    "top_products = merged_data.groupby(\"ProductName\")[\"TotalValue\"].sum().sort_values(ascending=False).head(5)\n",
    "\n",
    "# Visualization (e.g., sales trends, region analysis)\n",
    "plt.figure(figsize=(10, 6))\n",
    "sales_by_region.plot(kind=\"bar\", title=\"Total Sales by Region\")\n",
    "plt.xlabel(\"Region\")\n",
    "plt.ylabel(\"Total Sales\")\n",
    "plt.show()\n",
    "\n",
    "# Task 2: Lookalike Model\n",
    "# Feature engineering\n",
    "customer_features = merged_data.groupby(\"CustomerID\").agg({\n",
    "    \"TotalValue\": \"sum\",\n",
    "    \"TransactionID\": \"count\",\n",
    "    \"Price\": \"mean\"\n",
    "}).rename(columns={\"TotalValue\": \"TotalSpend\", \"TransactionID\": \"TransactionCount\", \"Price\": \"AvgPrice\"})\n",
    "\n",
    "# Ensure features are numerical and handle missing values if any\n",
    "customer_features = customer_features.fillna(0)\n",
    "\n",
    "# Compute similarity\n",
    "scaler = StandardScaler()\n",
    "scaled_features = scaler.fit_transform(customer_features)\n",
    "similarity_matrix = cosine_similarity(scaled_features)\n",
    "\n",
    "# Recommend top 3 lookalikes for each customer\n",
    "lookalikes = {}\n",
    "customer_ids = customer_features.index.tolist()\n",
    "for i, customer_id in enumerate(customer_ids):\n",
    "    similar_indices = np.argsort(-similarity_matrix[i])[1:4]  # Top 3 excluding self\n",
    "    lookalikes[customer_id] = [\n",
    "        (customer_ids[j], round(similarity_matrix[i, j], 4)) for j in similar_indices\n",
    "    ]\n",
    "\n",
    "# Save Lookalike results\n",
    "lookalike_df = pd.DataFrame({\n",
    "    \"CustomerID\": list(lookalikes.keys()),\n",
    "    \"Lookalikes\": [str(v) for v in lookalikes.values()]\n",
    "})\n",
    "lookalike_df.to_csv(\"Lookalike.csv\", index=False)\n",
    "\n",
    "# Task 3: Customer Segmentation (Clustering)\n",
    "# Prepare data for clustering\n",
    "clustering_data = customer_features.copy()\n",
    "scaled_clustering_data = scaler.fit_transform(clustering_data)\n",
    "\n",
    "# Apply KMeans clustering\n",
    "kmeans = KMeans(n_clusters=4, random_state=42)\n",
    "clusters = kmeans.fit_predict(scaled_clustering_data)\n",
    "clustering_data[\"Cluster\"] = clusters\n",
    "\n",
    "# Evaluate clustering\n",
    "db_index = davies_bouldin_score(scaled_clustering_data, clusters)\n",
    "\n",
    "# Visualize clusters\n",
    "plt.figure(figsize=(8, 6))\n",
    "sns.scatterplot(\n",
    "    x=clustering_data[\"TotalSpend\"],\n",
    "    y=clustering_data[\"TransactionCount\"],\n",
    "    hue=clustering_data[\"Cluster\"],\n",
    "    palette=\"viridis\",\n",
    "    legend=\"full\"\n",
    ")\n",
    "plt.title(\"Customer Clusters\")\n",
    "plt.xlabel(\"Total Spend\")\n",
    "plt.ylabel(\"Transaction Count\")\n",
    "plt.show()\n",
    "\n",
    "# Save clustering results\n",
    "clustering_data.to_csv(\"ClusteringResults.csv\", index=False)\n",
    "\n",
    "# Print summaries for review\n",
    "print(\"EDA Summary Statistics:\\n\", summary_stats)\n",
    "print(\"Top 5 Products by Sales:\\n\", top_products)\n",
    "print(\"Davies-Bouldin Index for Clustering:\", db_index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "da8bb81d-373f-4481-a0e5-51a43f764612",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "\"Column(s) ['Price'] do not exist\"",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[4], line 18\u001b[0m\n\u001b[0;32m     15\u001b[0m merged_data \u001b[38;5;241m=\u001b[39m transactions\u001b[38;5;241m.\u001b[39mmerge(customers, on\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCustomerID\u001b[39m\u001b[38;5;124m\"\u001b[39m)\u001b[38;5;241m.\u001b[39mmerge(products, on\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mProductID\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m     17\u001b[0m \u001b[38;5;66;03m# Feature engineering for clustering\u001b[39;00m\n\u001b[1;32m---> 18\u001b[0m customer_features \u001b[38;5;241m=\u001b[39m merged_data\u001b[38;5;241m.\u001b[39mgroupby(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCustomerID\u001b[39m\u001b[38;5;124m\"\u001b[39m)\u001b[38;5;241m.\u001b[39magg({\n\u001b[0;32m     19\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124msum\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     20\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mcount\u001b[39m\u001b[38;5;124m\"\u001b[39m,\n\u001b[0;32m     21\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmean\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m     22\u001b[0m })\u001b[38;5;241m.\u001b[39mrename(columns\u001b[38;5;241m=\u001b[39m{\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalValue\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTotalSpend\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionID\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTransactionCount\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAvgPrice\u001b[39m\u001b[38;5;124m\"\u001b[39m})\n\u001b[0;32m     24\u001b[0m \u001b[38;5;66;03m# Ensure features are numerical and handle missing values if any\u001b[39;00m\n\u001b[0;32m     25\u001b[0m customer_features \u001b[38;5;241m=\u001b[39m customer_features\u001b[38;5;241m.\u001b[39mfillna(\u001b[38;5;241m0\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\groupby\\generic.py:1432\u001b[0m, in \u001b[0;36mDataFrameGroupBy.aggregate\u001b[1;34m(self, func, engine, engine_kwargs, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1429\u001b[0m     kwargs[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m] \u001b[38;5;241m=\u001b[39m engine_kwargs\n\u001b[0;32m   1431\u001b[0m op \u001b[38;5;241m=\u001b[39m GroupByApply(\u001b[38;5;28mself\u001b[39m, func, args\u001b[38;5;241m=\u001b[39margs, kwargs\u001b[38;5;241m=\u001b[39mkwargs)\n\u001b[1;32m-> 1432\u001b[0m result \u001b[38;5;241m=\u001b[39m op\u001b[38;5;241m.\u001b[39magg()\n\u001b[0;32m   1433\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m is_dict_like(func) \u001b[38;5;129;01mand\u001b[39;00m result \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m   1434\u001b[0m     \u001b[38;5;66;03m# GH #52849\u001b[39;00m\n\u001b[0;32m   1435\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mas_index \u001b[38;5;129;01mand\u001b[39;00m is_list_like(func):\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:190\u001b[0m, in \u001b[0;36mApply.agg\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    187\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mapply_str()\n\u001b[0;32m    189\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_dict_like(func):\n\u001b[1;32m--> 190\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_dict_like()\n\u001b[0;32m    191\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m is_list_like(func):\n\u001b[0;32m    192\u001b[0m     \u001b[38;5;66;03m# we require a list, but not a 'str'\u001b[39;00m\n\u001b[0;32m    193\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_list_like()\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:423\u001b[0m, in \u001b[0;36mApply.agg_dict_like\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    415\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21magg_dict_like\u001b[39m(\u001b[38;5;28mself\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m DataFrame \u001b[38;5;241m|\u001b[39m Series:\n\u001b[0;32m    416\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    417\u001b[0m \u001b[38;5;124;03m    Compute aggregation in the case of a dict-like argument.\u001b[39;00m\n\u001b[0;32m    418\u001b[0m \n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    421\u001b[0m \u001b[38;5;124;03m    Result of aggregation.\u001b[39;00m\n\u001b[0;32m    422\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m--> 423\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39magg_or_apply_dict_like(op_name\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124magg\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:1608\u001b[0m, in \u001b[0;36mGroupByApply.agg_or_apply_dict_like\u001b[1;34m(self, op_name)\u001b[0m\n\u001b[0;32m   1603\u001b[0m     kwargs\u001b[38;5;241m.\u001b[39mupdate({\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mengine_kwargs\u001b[39m\u001b[38;5;124m\"\u001b[39m: engine_kwargs})\n\u001b[0;32m   1605\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m com\u001b[38;5;241m.\u001b[39mtemp_setattr(\n\u001b[0;32m   1606\u001b[0m     obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;28;01mTrue\u001b[39;00m, condition\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mhasattr\u001b[39m(obj, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mas_index\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m   1607\u001b[0m ):\n\u001b[1;32m-> 1608\u001b[0m     result_index, result_data \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcompute_dict_like(\n\u001b[0;32m   1609\u001b[0m         op_name, selected_obj, selection, kwargs\n\u001b[0;32m   1610\u001b[0m     )\n\u001b[0;32m   1611\u001b[0m result \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mwrap_results_dict_like(selected_obj, result_index, result_data)\n\u001b[0;32m   1612\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m result\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:462\u001b[0m, in \u001b[0;36mApply.compute_dict_like\u001b[1;34m(self, op_name, selected_obj, selection, kwargs)\u001b[0m\n\u001b[0;32m    460\u001b[0m is_groupby \u001b[38;5;241m=\u001b[39m \u001b[38;5;28misinstance\u001b[39m(obj, (DataFrameGroupBy, SeriesGroupBy))\n\u001b[0;32m    461\u001b[0m func \u001b[38;5;241m=\u001b[39m cast(AggFuncTypeDict, \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc)\n\u001b[1;32m--> 462\u001b[0m func \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mnormalize_dictlike_arg(op_name, selected_obj, func)\n\u001b[0;32m    464\u001b[0m is_non_unique_col \u001b[38;5;241m=\u001b[39m (\n\u001b[0;32m    465\u001b[0m     selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m2\u001b[39m\n\u001b[0;32m    466\u001b[0m     \u001b[38;5;129;01mand\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mcolumns\u001b[38;5;241m.\u001b[39mnunique() \u001b[38;5;241m<\u001b[39m \u001b[38;5;28mlen\u001b[39m(selected_obj\u001b[38;5;241m.\u001b[39mcolumns)\n\u001b[0;32m    467\u001b[0m )\n\u001b[0;32m    469\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m selected_obj\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m    470\u001b[0m     \u001b[38;5;66;03m# key only used for output\u001b[39;00m\n",
      "File \u001b[1;32m~\\anaconda3\\Lib\\site-packages\\pandas\\core\\apply.py:663\u001b[0m, in \u001b[0;36mApply.normalize_dictlike_arg\u001b[1;34m(self, how, obj, func)\u001b[0m\n\u001b[0;32m    661\u001b[0m     cols \u001b[38;5;241m=\u001b[39m Index(\u001b[38;5;28mlist\u001b[39m(func\u001b[38;5;241m.\u001b[39mkeys()))\u001b[38;5;241m.\u001b[39mdifference(obj\u001b[38;5;241m.\u001b[39mcolumns, sort\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[0;32m    662\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(cols) \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m--> 663\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mKeyError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mColumn(s) \u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mlist\u001b[39m(cols)\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m do not exist\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m    665\u001b[0m aggregator_types \u001b[38;5;241m=\u001b[39m (\u001b[38;5;28mlist\u001b[39m, \u001b[38;5;28mtuple\u001b[39m, \u001b[38;5;28mdict\u001b[39m)\n\u001b[0;32m    667\u001b[0m \u001b[38;5;66;03m# if we have a dict of any non-scalars\u001b[39;00m\n\u001b[0;32m    668\u001b[0m \u001b[38;5;66;03m# eg. {'A' : ['mean']}, normalize all to\u001b[39;00m\n\u001b[0;32m    669\u001b[0m \u001b[38;5;66;03m# be list-likes\u001b[39;00m\n\u001b[0;32m    670\u001b[0m \u001b[38;5;66;03m# Cannot use func.values() because arg may be a Series\u001b[39;00m\n",
      "\u001b[1;31mKeyError\u001b[0m: \"Column(s) ['Price'] do not exist\""
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score, silhouette_score\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "# Load the datasets\n",
    "customers = pd.read_csv(\"Customers.csv\")\n",
    "products = pd.read_csv(\"Products.csv\")\n",
    "transactions = pd.read_csv(\"Transactions.csv\")\n",
    "\n",
    "# Merge datasets for comprehensive analysis\n",
    "merged_data = transactions.merge(customers, on=\"CustomerID\").merge(products, on=\"ProductID\")\n",
    "\n",
    "# Feature engineering for clustering\n",
    "customer_features = merged_data.groupby(\"CustomerID\").agg({\n",
    "    \"TotalValue\": \"sum\",\n",
    "    \"TransactionID\": \"count\",\n",
    "    \"Price\": \"mean\"\n",
    "}).rename(columns={\"TotalValue\": \"TotalSpend\", \"TransactionID\": \"TransactionCount\", \"Price\": \"AvgPrice\"})\n",
    "\n",
    "# Ensure features are numerical and handle missing values if any\n",
    "customer_features = customer_features.fillna(0)\n",
    "\n",
    "# Standardize features\n",
    "scaler = StandardScaler()\n",
    "scaled_features = scaler.fit_transform(customer_features)\n",
    "\n",
    "# Apply KMeans clustering\n",
    "n_clusters = 4  # You can adjust this between 2 and 10\n",
    "kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n",
    "clusters = kmeans.fit_predict(scaled_features)\n",
    "customer_features[\"Cluster\"] = clusters\n",
    "\n",
    "# Evaluate clustering\n",
    "db_index = davies_bouldin_score(scaled_features, clusters)\n",
    "silhouette_avg = silhouette_score(scaled_features, clusters)\n",
    "\n",
    "# Visualize clusters\n",
    "plt.figure(figsize=(8, 6))\n",
    "sns.scatterplot(\n",
    "    x=customer_features[\"TotalSpend\"],\n",
    "    y=customer_features[\"TransactionCount\"],\n",
    "    hue=customer_features[\"Cluster\"],\n",
    "    palette=\"viridis\",\n",
    "    legend=\"full\"\n",
    ")\n",
    "plt.title(\"Customer Clusters\")\n",
    "plt.xlabel(\"Total Spend\")\n",
    "plt.ylabel(\"Transaction Count\")\n",
    "plt.show()\n",
    "\n",
    "# Save clustering results\n",
    "customer_features.to_csv(\"ClusteringResults.csv\", index=False)\n",
    "\n",
    "# Print clustering evaluation metrics\n",
    "print(f\"Number of Clusters: {n_clusters}\")\n",
    "print(f\"Davies-Bouldin Index: {db_index}\")\n",
    "print(f\"Silhouette Score: {silhouette_avg}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "947afc23-a2b4-47d5-a4ae-2a9534aa79e9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Error creating customer features: \"Column(s) ['Price'] do not exist\"\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "\n",
    "# Suppress warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "def load_and_merge_data():\n",
    "    \"\"\"Load and merge the datasets\"\"\"\n",
    "    try:\n",
    "        # Load datasets\n",
    "        customers = pd.read_csv(\"Customers.csv\")\n",
    "        products = pd.read_csv(\"Products.csv\")\n",
    "        transactions = pd.read_csv(\"Transactions.csv\")\n",
    "        \n",
    "        # Merge datasets\n",
    "        merged_data = (transactions.merge(customers, on=\"CustomerID\", how='left')\n",
    "                      .merge(products, on=\"ProductID\", how='left'))\n",
    "        \n",
    "        # Handle missing values\n",
    "        merged_data = merged_data.dropna()\n",
    "        \n",
    "        return customers, products, transactions, merged_data\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error loading data: {str(e)}\")\n",
    "        return None, None, None, None\n",
    "\n",
    "def perform_eda(merged_data):\n",
    "    \"\"\"Perform exploratory data analysis\"\"\"\n",
    "    try:\n",
    "        # Calculate basic statistics\n",
    "        summary_stats = merged_data.describe()\n",
    "        sales_by_region = merged_data.groupby(\"Region\")[\"TotalValue\"].sum()\n",
    "        top_products = (merged_data.groupby(\"ProductName\")[\"TotalValue\"]\n",
    "                       .sum()\n",
    "                       .sort_values(ascending=False)\n",
    "                       .head(5))\n",
    "        \n",
    "        # Create visualization\n",
    "        plt.figure(figsize=(12, 6))\n",
    "        sns.barplot(x=sales_by_region.index, y=sales_by_region.values)\n",
    "        plt.title(\"Total Sales by Region\")\n",
    "        plt.xlabel(\"Region\")\n",
    "        plt.ylabel(\"Total Sales\")\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(\"sales_by_region.png\")\n",
    "        plt.close()\n",
    "        \n",
    "        return summary_stats, sales_by_region, top_products\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error in EDA: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def create_customer_features(merged_data):\n",
    "    \"\"\"Create features for customer analysis\"\"\"\n",
    "    try:\n",
    "        customer_features = merged_data.groupby(\"CustomerID\").agg({\n",
    "            \"TotalValue\": \"sum\",\n",
    "            \"TransactionID\": \"count\",\n",
    "            \"Price\": \"mean\"\n",
    "        }).rename(columns={\n",
    "            \"TotalValue\": \"TotalSpend\",\n",
    "            \"TransactionID\": \"TransactionCount\",\n",
    "            \"Price\": \"AvgPrice\"\n",
    "        })\n",
    "        \n",
    "        return customer_features\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error creating customer features: {str(e)}\")\n",
    "        return None\n",
    "\n",
    "def build_lookalike_model(customer_features):\n",
    "    \"\"\"Build the lookalike model\"\"\"\n",
    "    try:\n",
    "        # Scale features\n",
    "        scaler = StandardScaler()\n",
    "        scaled_features = scaler.fit_transform(customer_features)\n",
    "        \n",
    "        # Calculate similarity\n",
    "        similarity_matrix = cosine_similarity(scaled_features)\n",
    "        \n",
    "        # Generate lookalikes\n",
    "        lookalikes = {}\n",
    "        customer_ids = customer_features.index.tolist()\n",
    "        \n",
    "        for i, customer_id in enumerate(customer_ids):\n",
    "            similar_indices = np.argsort(-similarity_matrix[i])[1:4]\n",
    "            lookalikes[customer_id] = [\n",
    "                (customer_ids[j], float(round(similarity_matrix[i, j], 4)))\n",
    "                for j in similar_indices\n",
    "            ]\n",
    "        \n",
    "        # Create and save results\n",
    "        lookalike_df = pd.DataFrame({\n",
    "            \"CustomerID\": list(lookalikes.keys()),\n",
    "            \"Lookalikes\": [str(v) for v in lookalikes.values()]\n",
    "        })\n",
    "        lookalike_df.to_csv(\"FirstName_LastName_Lookalike.csv\", index=False)\n",
    "        \n",
    "        return lookalikes, lookalike_df\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error building lookalike model: {str(e)}\")\n",
    "        return None, None\n",
    "\n",
    "def perform_clustering(customer_features):\n",
    "    \"\"\"Perform customer segmentation\"\"\"\n",
    "    try:\n",
    "        # Prepare data\n",
    "        clustering_data = customer_features.copy()\n",
    "        scaler = StandardScaler()\n",
    "        scaled_clustering_data = scaler.fit_transform(clustering_data)\n",
    "        \n",
    "        # Find optimal number of clusters\n",
    "        n_clusters_range = range(2, 11)\n",
    "        db_scores = []\n",
    "        \n",
    "        for n_clusters in n_clusters_range:\n",
    "            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n",
    "            clusters = kmeans.fit_predict(scaled_clustering_data)\n",
    "            db_score = davies_bouldin_score(scaled_clustering_data, clusters)\n",
    "            db_scores.append(db_score)\n",
    "        \n",
    "        # Select optimal number of clusters\n",
    "        optimal_clusters = n_clusters_range[np.argmin(db_scores)]\n",
    "        \n",
    "        # Final clustering with optimal number\n",
    "        kmeans = KMeans(n_clusters=optimal_clusters, random_state=42, n_init=10)\n",
    "        clusters = kmeans.fit_predict(scaled_clustering_data)\n",
    "        clustering_data[\"Cluster\"] = clusters\n",
    "        \n",
    "        # Calculate Davies-Bouldin Index\n",
    "        db_index = davies_bouldin_score(scaled_clustering_data, clusters)\n",
    "        \n",
    "        # Create visualization\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        sns.scatterplot(\n",
    "            data=clustering_data,\n",
    "            x=\"TotalSpend\",\n",
    "            y=\"TransactionCount\",\n",
    "            hue=\"Cluster\",\n",
    "            palette=\"viridis\",\n",
    "            legend=\"full\"\n",
    "        )\n",
    "        plt.title(f\"Customer Clusters (n={optimal_clusters})\")\n",
    "        plt.xlabel(\"Total Spend\")\n",
    "        plt.ylabel(\"Transaction Count\")\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(\"customer_clusters.png\")\n",
    "        plt.close()\n",
    "        \n",
    "        # Save clustering results\n",
    "        clustering_data.to_csv(\"FirstName_LastName_Clustering.csv\", index=True)\n",
    "        \n",
    "        return clustering_data, db_index, optimal_clusters\n",
    "    \n",
    "    except Exception as e:\n",
    "        print(f\"Error performing clustering: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main execution function\"\"\"\n",
    "    try:\n",
    "        # Load and merge data\n",
    "        customers, products, transactions, merged_data = load_and_merge_data()\n",
    "        if merged_data is None:\n",
    "            return\n",
    "        \n",
    "        # Perform EDA\n",
    "        summary_stats, sales_by_region, top_products = perform_eda(merged_data)\n",
    "        if summary_stats is None:\n",
    "            return\n",
    "        \n",
    "        # Create customer features\n",
    "        customer_features = create_customer_features(merged_data)\n",
    "        if customer_features is None:\n",
    "            return\n",
    "        \n",
    "        # Build lookalike model\n",
    "        lookalikes, lookalike_df = build_lookalike_model(customer_features)\n",
    "        if lookalikes is None:\n",
    "            return\n",
    "        \n",
    "        # Perform clustering\n",
    "        clustering_data, db_index, optimal_clusters = perform_clustering(customer_features)\n",
    "        if clustering_data is None:\n",
    "            return\n",
    "        \n",
    "        # Print summaries\n",
    "        print(\"\\nEDA Summary Statistics:\")\n",
    "        print(summary_stats)\n",
    "        print(\"\\nTop 5 Products by Sales:\")\n",
    "        print(top_products)\n",
    "        print(f\"\\nDavies-Bouldin Index for Clustering: {db_index:.4f}\")\n",
    "        print(f\"Optimal number of clusters: {optimal_clusters}\")\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"Error in main execution: {str(e)}\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "db457a7f-1ad6-445a-8f7d-8e344da8d047",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Analysis Complete!\n",
      "\n",
      "Total Customers: 200\n",
      "Total Products: 100\n",
      "Total Transactions: 1000\n",
      "\n",
      "Optimal Number of Clusters: 9\n",
      "Davies-Bouldin Index: 1.0298\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "from datetime import datetime\n",
    "\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "def load_data():\n",
    "    \"\"\"Load datasets with proper data types and date parsing\"\"\"\n",
    "    try:\n",
    "        # Load Customers with proper date parsing\n",
    "        customers = pd.read_csv(\"Customers.csv\", dtype={\n",
    "            'CustomerID': str,\n",
    "            'CustomerName': str,\n",
    "            'Region': str\n",
    "        }, parse_dates=['SignupDate'])\n",
    "\n",
    "        # Load Products\n",
    "        products = pd.read_csv(\"Products.csv\", dtype={\n",
    "            'ProductID': str,\n",
    "            'ProductName': str,\n",
    "            'Category': str,\n",
    "            'Price': float\n",
    "        })\n",
    "\n",
    "        # Load Transactions with proper date parsing\n",
    "        transactions = pd.read_csv(\"Transactions.csv\", dtype={\n",
    "            'TransactionID': str,\n",
    "            'CustomerID': str,\n",
    "            'ProductID': str,\n",
    "            'Quantity': int,\n",
    "            'TotalValue': float,\n",
    "            'Price': float\n",
    "        }, parse_dates=['TransactionDate'])\n",
    "\n",
    "        return customers, products, transactions\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error loading data: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def perform_eda(customers, products, transactions):\n",
    "    \"\"\"Perform EDA focusing on key business metrics\"\"\"\n",
    "    try:\n",
    "        # 1. Customer Analysis\n",
    "        customer_metrics = {\n",
    "            'total_customers': len(customers),\n",
    "            'customers_by_region': customers['Region'].value_counts(),\n",
    "            'avg_customer_age_days': (datetime.now() - customers['SignupDate']).mean().days,\n",
    "            'customers_by_signup_year': customers['SignupDate'].dt.year.value_counts().sort_index()\n",
    "        }\n",
    "\n",
    "        # 2. Product Analysis\n",
    "        product_metrics = {\n",
    "            'total_products': len(products),\n",
    "            'categories': products['Category'].value_counts(),\n",
    "            'price_range': {\n",
    "                'min': products['Price'].min(),\n",
    "                'max': products['Price'].max(),\n",
    "                'mean': products['Price'].mean()\n",
    "            },\n",
    "            'products_by_category': products.groupby('Category')['Price'].agg(['count', 'mean'])\n",
    "        }\n",
    "\n",
    "        # 3. Transaction Analysis\n",
    "        transaction_metrics = {\n",
    "            'total_transactions': len(transactions),\n",
    "            'total_revenue': transactions['TotalValue'].sum(),\n",
    "            'avg_transaction_value': transactions['TotalValue'].mean(),\n",
    "            'total_quantity_sold': transactions['Quantity'].sum(),\n",
    "            'sales_by_month': transactions.groupby(transactions['TransactionDate'].dt.to_period('M'))['TotalValue'].sum()\n",
    "        }\n",
    "\n",
    "        # Visualizations\n",
    "        # 1. Sales Trend\n",
    "        plt.figure(figsize=(12, 6))\n",
    "        transaction_metrics['sales_by_month'].plot(kind='line')\n",
    "        plt.title('Monthly Sales Trend')\n",
    "        plt.xlabel('Month')\n",
    "        plt.ylabel('Total Sales')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig('sales_trend.png')\n",
    "        plt.close()\n",
    "\n",
    "        # 2. Category Distribution\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        product_metrics['categories'].plot(kind='bar')\n",
    "        plt.title('Product Distribution by Category')\n",
    "        plt.xlabel('Category')\n",
    "        plt.ylabel('Number of Products')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig('category_distribution.png')\n",
    "        plt.close()\n",
    "\n",
    "        return customer_metrics, product_metrics, transaction_metrics\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error in EDA: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def create_customer_features(customers, transactions):\n",
    "    \"\"\"Create comprehensive customer features for modeling\"\"\"\n",
    "    try:\n",
    "        # Calculate customer metrics\n",
    "        customer_features = transactions.groupby('CustomerID').agg({\n",
    "            'TransactionID': 'count',  # Number of transactions\n",
    "            'TotalValue': ['sum', 'mean'],  # Spending patterns\n",
    "            'Quantity': ['sum', 'mean'],  # Buying patterns\n",
    "            'TransactionDate': ['min', 'max']  # Customer lifecycle\n",
    "        }).reset_index()\n",
    "\n",
    "        # Flatten column names\n",
    "        customer_features.columns = [\n",
    "            'CustomerID', 'transaction_count', 'total_spend', 'avg_transaction_value',\n",
    "            'total_quantity', 'avg_quantity', 'first_purchase', 'last_purchase'\n",
    "        ]\n",
    "\n",
    "        # Add customer profile information\n",
    "        customer_features = customer_features.merge(\n",
    "            customers[['CustomerID', 'Region', 'SignupDate']], \n",
    "            on='CustomerID'\n",
    "        )\n",
    "\n",
    "        # Calculate derived features\n",
    "        customer_features['account_age_days'] = (\n",
    "            customer_features['last_purchase'] - customer_features['SignupDate']\n",
    "        ).dt.days\n",
    "        customer_features['purchase_frequency'] = customer_features['transaction_count'] / \\\n",
    "                                                customer_features['account_age_days']\n",
    "\n",
    "        # Handle infinite values\n",
    "        customer_features = customer_features.replace([np.inf, -np.inf], np.nan)\n",
    "        customer_features = customer_features.fillna(0)\n",
    "\n",
    "        # Convert Region to dummy variables\n",
    "        customer_features = pd.get_dummies(customer_features, columns=['Region'], prefix='region')\n",
    "\n",
    "        return customer_features\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error creating customer features: {str(e)}\")\n",
    "        return None\n",
    "\n",
    "def build_lookalike_model(customer_features, n_recommendations=3):\n",
    "    \"\"\"Build lookalike model with enhanced similarity metrics\"\"\"\n",
    "    try:\n",
    "        # Select features for similarity calculation\n",
    "        similarity_features = customer_features.drop(\n",
    "            ['CustomerID', 'first_purchase', 'last_purchase', 'SignupDate'], \n",
    "            axis=1\n",
    "        )\n",
    "\n",
    "        # Scale features\n",
    "        scaler = StandardScaler()\n",
    "        scaled_features = scaler.fit_transform(similarity_features)\n",
    "\n",
    "        # Calculate similarity\n",
    "        similarity_matrix = cosine_similarity(scaled_features)\n",
    "\n",
    "        # Generate recommendations\n",
    "        lookalikes = {}\n",
    "        customer_ids = customer_features['CustomerID'].tolist()\n",
    "\n",
    "        for i, customer_id in enumerate(customer_ids[:20]):  # First 20 customers as required\n",
    "            similar_indices = np.argsort(-similarity_matrix[i])[1:n_recommendations+1]\n",
    "            lookalikes[customer_id] = [\n",
    "                (customer_ids[j], float(round(similarity_matrix[i, j], 4)))\n",
    "                for j in similar_indices\n",
    "            ]\n",
    "\n",
    "        # Save results\n",
    "        lookalike_results = []\n",
    "        for cust_id, recommendations in lookalikes.items():\n",
    "            for rec_id, score in recommendations:\n",
    "                lookalike_results.append({\n",
    "                    'customer_id': cust_id,\n",
    "                    'similar_customer_id': rec_id,\n",
    "                    'similarity_score': score\n",
    "                })\n",
    "\n",
    "        lookalike_df = pd.DataFrame(lookalike_results)\n",
    "        lookalike_df.to_csv('FirstName_LastName_Lookalike.csv', index=False)\n",
    "\n",
    "        return lookalikes, lookalike_df\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error building lookalike model: {str(e)}\")\n",
    "        return None, None\n",
    "\n",
    "def perform_clustering(customer_features):\n",
    "    \"\"\"Perform customer segmentation with optimal cluster selection\"\"\"\n",
    "    try:\n",
    "        # Prepare features for clustering\n",
    "        cluster_features = customer_features.drop(\n",
    "            ['CustomerID', 'first_purchase', 'last_purchase', 'SignupDate'], \n",
    "            axis=1\n",
    "        )\n",
    "\n",
    "        # Scale features\n",
    "        scaler = StandardScaler()\n",
    "        scaled_features = scaler.fit_transform(cluster_features)\n",
    "\n",
    "        # Find optimal number of clusters\n",
    "        min_clusters, max_clusters = 2, 10\n",
    "        db_scores = []\n",
    "        models = {}\n",
    "\n",
    "        for n_clusters in range(min_clusters, max_clusters + 1):\n",
    "            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n",
    "            labels = kmeans.fit_predict(scaled_features)\n",
    "            db_score = davies_bouldin_score(scaled_features, labels)\n",
    "            db_scores.append(db_score)\n",
    "            models[n_clusters] = kmeans\n",
    "\n",
    "        # Select optimal number of clusters\n",
    "        optimal_clusters = min_clusters + np.argmin(db_scores)\n",
    "        best_model = models[optimal_clusters]\n",
    "\n",
    "        # Final clustering\n",
    "        cluster_labels = best_model.predict(scaled_features)\n",
    "        customer_features['Cluster'] = cluster_labels\n",
    "\n",
    "        # Analyze clusters\n",
    "        cluster_analysis = customer_features.groupby('Cluster').agg({\n",
    "            'total_spend': 'mean',\n",
    "            'transaction_count': 'mean',\n",
    "            'avg_transaction_value': 'mean',\n",
    "            'purchase_frequency': 'mean'\n",
    "        })\n",
    "\n",
    "        # Save results\n",
    "        customer_features.to_csv('FirstName_LastName_Clustering.csv', index=False)\n",
    "\n",
    "        return customer_features, db_scores[optimal_clusters-min_clusters], optimal_clusters, cluster_analysis\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error performing clustering: {str(e)}\")\n",
    "        return None, None, None, None\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main execution function\"\"\"\n",
    "    try:\n",
    "        # Load data\n",
    "        customers, products, transactions = load_data()\n",
    "        if any(df is None for df in [customers, products, transactions]):\n",
    "            return\n",
    "\n",
    "        # Perform EDA\n",
    "        customer_metrics, product_metrics, transaction_metrics = perform_eda(\n",
    "            customers, products, transactions\n",
    "        )\n",
    "        if any(metric is None for metric in [customer_metrics, product_metrics, transaction_metrics]):\n",
    "            return\n",
    "\n",
    "        # Create customer features\n",
    "        customer_features = create_customer_features(customers, transactions)\n",
    "        if customer_features is None:\n",
    "            return\n",
    "\n",
    "        # Build lookalike model\n",
    "        lookalikes, lookalike_df = build_lookalike_model(customer_features)\n",
    "        if lookalikes is None:\n",
    "            return\n",
    "\n",
    "        # Perform clustering\n",
    "        clustering_results, db_index, optimal_clusters, cluster_analysis = perform_clustering(\n",
    "            customer_features\n",
    "        )\n",
    "        if clustering_results is None:\n",
    "            return\n",
    "\n",
    "        # Print summary results\n",
    "        print(\"\\nAnalysis Complete!\")\n",
    "        print(f\"\\nTotal Customers: {customer_metrics['total_customers']}\")\n",
    "        print(f\"Total Products: {product_metrics['total_products']}\")\n",
    "        print(f\"Total Transactions: {transaction_metrics['total_transactions']}\")\n",
    "        print(f\"\\nOptimal Number of Clusters: {optimal_clusters}\")\n",
    "        print(f\"Davies-Bouldin Index: {db_index:.4f}\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error in main execution: {str(e)}\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a8958d93-406e-40ae-84f4-0b5c983f0a57",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.metrics import davies_bouldin_score\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "from datetime import datetime\n",
    "\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "def load_data():\n",
    "    \"\"\"Load datasets with proper data types and date parsing\"\"\"\n",
    "    try:\n",
    "        # Load Customers with proper date parsing\n",
    "        customers = pd.read_csv(\"Customers.csv\", dtype={\n",
    "            'CustomerID': str,\n",
    "            'CustomerName': str,\n",
    "            'Region': str\n",
    "        }, parse_dates=['SignupDate'])\n",
    "\n",
    "        # Load Products\n",
    "        products = pd.read_csv(\"Products.csv\", dtype={\n",
    "            'ProductID': str,\n",
    "            'ProductName': str,\n",
    "            'Category': str,\n",
    "            'Price': float\n",
    "        })\n",
    "\n",
    "        # Load Transactions with proper date parsing\n",
    "        transactions = pd.read_csv(\"Transactions.csv\", dtype={\n",
    "            'TransactionID': str,\n",
    "            'CustomerID': str,\n",
    "            'ProductID': str,\n",
    "            'Quantity': int,\n",
    "            'TotalValue': float,\n",
    "            'Price': float\n",
    "        }, parse_dates=['TransactionDate'])\n",
    "\n",
    "        return customers, products, transactions\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error loading data: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def perform_eda(customers, products, transactions):\n",
    "    \"\"\"Perform EDA focusing on key business metrics\"\"\"\n",
    "    try:\n",
    "        # 1. Customer Analysis\n",
    "        customer_metrics = {\n",
    "            'total_customers': len(customers),\n",
    "            'customers_by_region': customers['Region'].value_counts(),\n",
    "            'avg_customer_age_days': (datetime.now() - customers['SignupDate']).mean().days,\n",
    "            'customers_by_signup_year': customers['SignupDate'].dt.year.value_counts().sort_index()\n",
    "        }\n",
    "\n",
    "        # 2. Product Analysis\n",
    "        product_metrics = {\n",
    "            'total_products': len(products),\n",
    "            'categories': products['Category'].value_counts(),\n",
    "            'price_range': {\n",
    "                'min': products['Price'].min(),\n",
    "                'max': products['Price'].max(),\n",
    "                'mean': products['Price'].mean()\n",
    "            },\n",
    "            'products_by_category': products.groupby('Category')['Price'].agg(['count', 'mean'])\n",
    "        }\n",
    "\n",
    "        # 3. Transaction Analysis\n",
    "        transaction_metrics = {\n",
    "            'total_transactions': len(transactions),\n",
    "            'total_revenue': transactions['TotalValue'].sum(),\n",
    "            'avg_transaction_value': transactions['TotalValue'].mean(),\n",
    "            'total_quantity_sold': transactions['Quantity'].sum(),\n",
    "            'sales_by_month': transactions.groupby(transactions['TransactionDate'].dt.to_period('M'))['TotalValue'].sum()\n",
    "        }\n",
    "\n",
    "        # Visualizations\n",
    "        # 1. Sales Trend\n",
    "        plt.figure(figsize=(12, 6))\n",
    "        transaction_metrics['sales_by_month'].plot(kind='line')\n",
    "        plt.title('Monthly Sales Trend')\n",
    "        plt.xlabel('Month')\n",
    "        plt.ylabel('Total Sales')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig('sales_trend.png')\n",
    "        plt.close()\n",
    "\n",
    "        # 2. Category Distribution\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        product_metrics['categories'].plot(kind='bar')\n",
    "        plt.title('Product Distribution by Category')\n",
    "        plt.xlabel('Category')\n",
    "        plt.ylabel('Number of Products')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.tight_layout()\n",
    "        plt.savefig('category_distribution.png')\n",
    "        plt.close()\n",
    "\n",
    "        return customer_metrics, product_metrics, transaction_metrics\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error in EDA: {str(e)}\")\n",
    "        return None, None, None\n",
    "\n",
    "def create_customer_features(customers, transactions):\n",
    "    \"\"\"Create comprehensive customer features for modeling\"\"\"\n",
    "    try:\n",
    "        # Calculate customer metrics\n",
    "        customer_features = transactions.groupby('CustomerID').agg({\n",
    "            'TransactionID': 'count',  # Number of transactions\n",
    "            'TotalValue': ['sum', 'mean'],  # Spending patterns\n",
    "            'Quantity': ['sum', 'mean'],  # Buying patterns\n",
    "            'TransactionDate': ['min', 'max']  # Customer lifecycle\n",
    "        }).reset_index()\n",
    "\n",
    "        # Flatten column names\n",
    "        customer_features.columns = [\n",
    "            'CustomerID', 'transaction_count', 'total_spend', 'avg_transaction_value',\n",
    "            'total_quantity', 'avg_quantity', 'first_purchase', 'last_purchase'\n",
    "        ]\n",
    "\n",
    "        # Add customer profile information\n",
    "        customer_features = customer_features.merge(\n",
    "            customers[['CustomerID', 'Region', 'SignupDate']], \n",
    "            on='CustomerID'\n",
    "        )\n",
    "\n",
    "        # Calculate derived features\n",
    "        customer_features['account_age_days'] = (\n",
    "            customer_features['last_purchase'] - customer_features['SignupDate']\n",
    "        ).dt.days\n",
    "        customer_features['purchase_frequency'] = customer_features['transaction_count'] / \\\n",
    "                                                customer_features['account_age_days']\n",
    "\n",
    "        # Handle infinite values\n",
    "        customer_features = customer_features.replace([np.inf, -np.inf], np.nan)\n",
    "        customer_features = customer_features.fillna(0)\n",
    "\n",
    "        # Convert Region to dummy variables\n",
    "        customer_features = pd.get_dummies(customer_features, columns=['Region'], prefix='region')\n",
    "\n",
    "        return customer_features\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error creating customer features: {str(e)}\")\n",
    "        return None\n",
    "\n",
    "def build_lookalike_model(customer_features, n_recommendations=3):\n",
    "    \"\"\"Build lookalike model with enhanced similarity metrics\"\"\"\n",
    "    try:\n",
    "        # Select features for similarity calculation\n",
    "        similarity_features = customer_features.drop(\n",
    "            ['CustomerID', 'first_purchase', 'last_purchase', 'SignupDate'], \n",
    "            axis=1\n",
    "        )\n",
    "\n",
    "        # Scale features\n",
    "        scaler = StandardScaler()\n",
    "        scaled_features = scaler.fit_transform(similarity_features)\n",
    "\n",
    "        # Calculate similarity\n",
    "        similarity_matrix = cosine_similarity(scaled_features)\n",
    "\n",
    "        # Generate recommendations\n",
    "        lookalikes = {}\n",
    "        customer_ids = customer_features['CustomerID'].tolist()\n",
    "\n",
    "        for i, customer_id in enumerate(customer_ids[:20]):  # First 20 customers as required\n",
    "            similar_indices = np.argsort(-similarity_matrix[i])[1:n_recommendations+1]\n",
    "            lookalikes[customer_id] = [\n",
    "                (customer_ids[j], float(round(similarity_matrix[i, j], 4)))\n",
    "                for j in similar_indices\n",
    "            ]\n",
    "\n",
    "        # Save results\n",
    "        lookalike_results = []\n",
    "        for cust_id, recommendations in lookalikes.items():\n",
    "            for rec_id, score in recommendations:\n",
    "                lookalike_results.append({\n",
    "                    'customer_id': cust_id,\n",
    "                    'similar_customer_id': rec_id,\n",
    "                    'similarity_score': score\n",
    "                })\n",
    "\n",
    "        lookalike_df = pd.DataFrame(lookalike_results)\n",
    "        lookalike_df.to_csv('FirstName_LastName_Lookalike.csv', index=False)\n",
    "\n",
    "        return lookalikes, lookalike_df\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error building lookalike model: {str(e)}\")\n",
    "        return None, None\n",
    "\n",
    "def perform_clustering(customer_features):\n",
    "    \"\"\"Perform customer segmentation with optimal cluster selection\"\"\"\n",
    "    try:\n",
    "        # Prepare features for clustering\n",
    "        cluster_features = customer_features.drop(\n",
    "            ['CustomerID', 'first_purchase', 'last_purchase', 'SignupDate'], \n",
    "            axis=1\n",
    "        )\n",
    "\n",
    "        # Scale features\n",
    "        scaler = StandardScaler()\n",
    "        scaled_features = scaler.fit_transform(cluster_features)\n",
    "\n",
    "        # Find optimal number of clusters\n",
    "        min_clusters, max_clusters = 2, 10\n",
    "        db_scores = []\n",
    "        models = {}\n",
    "\n",
    "        for n_clusters in range(min_clusters, max_clusters + 1):\n",
    "            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n",
    "            labels = kmeans.fit_predict(scaled_features)\n",
    "            db_score = davies_bouldin_score(scaled_features, labels)\n",
    "            db_scores.append(db_score)\n",
    "            models[n_clusters] = kmeans\n",
    "\n",
    "        # Select optimal number of clusters\n",
    "        optimal_clusters = min_clusters + np.argmin(db_scores)\n",
    "        best_model = models[optimal_clusters]\n",
    "\n",
    "        # Final clustering\n",
    "        cluster_labels = best_model.predict(scaled_features)\n",
    "        customer_features['Cluster'] = cluster_labels\n",
    "\n",
    "        # Analyze clusters\n",
    "        cluster_analysis = customer_features.groupby('Cluster').agg({\n",
    "            'total_spend': 'mean',\n",
    "            'transaction_count': 'mean',\n",
    "            'avg_transaction_value': 'mean',\n",
    "            'purchase_frequency': 'mean'\n",
    "        })\n",
    "\n",
    "        # Save results\n",
    "        customer_features.to_csv('FirstName_LastName_Clustering.csv', index=False)\n",
    "\n",
    "        return customer_features, db_scores[optimal_clusters-min_clusters], optimal_clusters, cluster_analysis\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error performing clustering: {str(e)}\")\n",
    "        return None, None, None, None\n",
    "\n",
    "def main():\n",
    "    \"\"\"Main execution function\"\"\"\n",
    "    try:\n",
    "        # Load data\n",
    "        customers, products, transactions = load_data()\n",
    "        if any(df is None for df in [customers, products, transactions]):\n",
    "            return\n",
    "\n",
    "        # Perform EDA\n",
    "        customer_metrics, product_metrics, transaction_metrics = perform_eda(\n",
    "            customers, products, transactions\n",
    "        )\n",
    "        if any(metric is None for metric in [customer_metrics, product_metrics, transaction_metrics]):\n",
    "            return\n",
    "\n",
    "        # Create customer features\n",
    "        customer_features = create_customer_features(customers, transactions)\n",
    "        if customer_features is None:\n",
    "            return\n",
    "\n",
    "        # Build lookalike model\n",
    "        lookalikes, lookalike_df = build_lookalike_model(customer_features)\n",
    "        if lookalikes is None:\n",
    "            return\n",
    "\n",
    "        # Perform clustering\n",
    "        clustering_results, db_index, optimal_clusters, cluster_analysis = perform_clustering(\n",
    "            customer_features\n",
    "        )\n",
    "        if clustering_results is None:\n",
    "            return\n",
    "\n",
    "        # Print summary results\n",
    "        print(\"\\nAnalysis Complete!\")\n",
    "        print(f\"\\nTotal Customers: {customer_metrics['total_customers']}\")\n",
    "        print(f\"Total Products: {product_metrics['total_products']}\")\n",
    "        print(f\"Total Transactions: {transaction_metrics['total_transactions']}\")\n",
    "        print(f\"\\nOptimal Number of Clusters: {optimal_clusters}\")\n",
    "        print(f\"Davies-Bouldin Index: {db_index:.4f}\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error in main execution: {str(e)}\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ed0d3632-52f7-47a8-90eb-c938f37f39be",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
